<!DOCTYPE html><html lang=en> <head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width, initial-scale=1.0"><link rel="shortcut icon" href=../../img/favicon.ico><meta name=viewport content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"><title>C++11线程中的几种锁 - 记录</title><link href=../../css/bootstrap-3.3.7.min.css rel=stylesheet><link href=../../css/font-awesome-4.7.0.css rel=stylesheet><link href=../../css/base.css rel=stylesheet><link rel=stylesheet href=../../css/highlight.css><!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries --><!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]--><script src=../../js/jquery-3.2.1.min.js></script><script src=../../js/bootstrap-3.3.7.min.js></script><script src=../../js/highlight.pack.js></script><base target=_top><script>
      var base_url = '../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\u3010\u8f6c\u8f7d\u3011C++11\u7ebf\u7a0b\u4e2d\u7684\u51e0\u79cd\u9501", url: "#_top", children: [
              {title: "\u4e92\u65a5\u9501\uff08Mutex\uff09", url: "#mutex" },
              {title: "\u6761\u4ef6\u9501", url: "#_1" },
              {title: "\u81ea\u65cb\u9501", url: "#_2" },
              {title: "\u8bfb\u5199\u9501", url: "#_3" },
          ]},
        ];

    </script><script src=../../js/base.js></script></head> <body> <script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script> <div class="container-fluid wm-page-content"> <a name=_top></a> <div class="row wm-article-nav-buttons" role=navigation aria-label=navigation> <div class="wm-article-nav pull-right"> <a href=../../Libevent/ class="btn btn-xs btn-default pull-right"> Next <i class="fa fa-chevron-right" aria-hidden=true></i> </a> <a href=../../Libevent/ class="btn btn-xs btn-link"> 开始 </a> </div> <div class=wm-article-nav> <a href=../%E6%AD%BB%E5%BE%AA%E7%8E%AF%E5%86%85%E7%9A%84sleep%E5%87%BD%E6%95%B0/ class="btn btn-xs btn-default pull-left"> <i class="fa fa-chevron-left" aria-hidden=true></i> Previous</a><a href=../%E6%AD%BB%E5%BE%AA%E7%8E%AF%E5%86%85%E7%9A%84sleep%E5%87%BD%E6%95%B0/ class="btn btn-xs btn-link"> 死循环内的sleep函数 </a> </div> </div> <h1 id=c11>【转载】C++11线程中的几种锁<a class=headerlink href=#c11 title="Permanent link">&para;</a></h1> <p>线程之间的锁有：<strong>互斥锁、条件锁、自旋锁、读写锁、递归锁</strong>。一般而言，锁的功能与性能成反比。不过我们一般不使用递归锁（C++标准库提供了std::recursive_mutex），所以这里就不推荐了。</p> <h2 id=mutex>互斥锁（Mutex）<a class=headerlink href=#mutex title="Permanent link">&para;</a></h2> <p>互斥锁用于控制多个线程对他们之间共享资源互斥访问的一个信号量。也就是说是为了避免多个线程在某一时刻同时操作一个共享资源。例如线程池中的有多个空闲线程和一个任务队列。任何是一个线程都要使用互斥锁互斥访问任务队列，以避免多个线程同时访问任务队列以发生错乱。</p> <p>在某一时刻，只有一个线程可以获取互斥锁，在释放互斥锁之前其他线程都不能获取该互斥锁。如果其他线程想要获取这个互斥锁，那么这个线程只能以阻塞方式进行等待。</p> <p>头文件：&lt; mutex &gt; 类型： std::mutex 用法：在C++中，通过构造std::mutex的实例创建互斥元，调用成员函数lock()来锁定它，调用unlock()来解锁，不过一般不推荐这种做法，标准C++库提供了std::lock_guard类模板，实现了互斥元的RAII惯用语法。std::mutex和std::lock _ guard。都声明在&lt; mutex &gt;头文件中。</p> <p>参考代码：</p> <div class=highlight><pre><span></span><code><span class=c1>//用互斥元保护列表</span>
<span class=cp>#include</span> <span class=cpf>&lt;list&gt;</span><span class=cp></span>
<span class=cp>#include</span> <span class=cpf>&lt;mutex&gt;</span><span class=cp></span>

<span class=n>std</span><span class=o>::</span><span class=n>list</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>some_list</span><span class=p>;</span>
<span class=n>std</span><span class=o>::</span><span class=n>mutex</span> <span class=n>some_mutex</span><span class=p>;</span>

<span class=kt>void</span> <span class=nf>add_to_list</span><span class=p>(</span><span class=kt>int</span> <span class=n>new_value</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>std</span><span class=o>::</span><span class=n>lock_guard</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>mutex</span><span class=o>&gt;</span> <span class=n>guard</span><span class=p>(</span><span class=n>some_mutex</span><span class=p>);</span>
    <span class=n>some_list</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>new_value</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div> <p>互斥锁又可分为两种：<strong>递归锁</strong> 和 <strong>非递归锁</strong> 。</p> <p>同一个线程可以多次获取同一个递归锁，不会产生死锁。而如果一个线程多次获取同一个非递归锁，则会产生死锁。</p> <p>互斥锁默认属性是非递归的，</p> <h2 id=_1>条件锁<a class=headerlink href=#_1 title="Permanent link">&para;</a></h2> <p>条件锁就是所谓的条件变量，某一个线程因为某个条件为满足时可以使用条件变量使改程序处于阻塞状态。一旦条件满足以“信号量”的方式唤醒一个因为该条件而被阻塞的线程。最为常见就是在线程池中，起初没有任务时任务队列为空，此时线程池中的线程因为“任务队列为空”这个条件处于阻塞状态。一旦有任务进来，就会以信号量的方式唤醒一个线程来处理这个任务。</p> <p>头文件：&lt; condition_variable &gt; 类型：std::condition_variable（只和std::mutex一起工作） 和 std::condition_variable_any（符合类似互斥元的最低标准的任何东西一起工作）。</p> <div class=highlight><pre><span></span><code><span class=c1>//使用std::condition_variable等待数据</span>
<span class=n>std</span><span class=o>::</span><span class=n>mutex</span> <span class=n>mut</span><span class=p>;</span>
<span class=n>std</span><span class=o>::</span><span class=n>queue</span><span class=o>&lt;</span><span class=n>data_chunk</span><span class=o>&gt;</span> <span class=n>data_queue</span><span class=p>;</span>
<span class=n>std</span><span class=o>::</span><span class=n>condition_variable</span> <span class=n>data_cond</span><span class=p>;</span>

<span class=kt>void</span> <span class=nf>data_preparation_thread</span><span class=p>()</span>
<span class=p>{</span>
    <span class=k>while</span><span class=p>(</span><span class=n>more_data_to_prepare</span><span class=p>())</span>
    <span class=p>{</span>
        <span class=n>data_chunk</span> <span class=k>const</span> <span class=n>data</span><span class=o>=</span><span class=n>prepare_data</span><span class=p>();</span>
        <span class=n>std</span><span class=o>::</span><span class=n>lock_guard</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>mutex</span><span class=o>&gt;</span> <span class=n>lk</span><span class=p>(</span><span class=n>mut</span><span class=p>);</span>
        <span class=n>data_queue</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>data</span><span class=p>);</span>
        <span class=n>data_cond</span><span class=p>.</span><span class=n>notify_one</span><span class=p>();</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=kt>void</span> <span class=nf>data_processing_thread</span><span class=p>()</span>
<span class=p>{</span>
    <span class=k>while</span><span class=p>(</span><span class=nb>true</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=n>std</span><span class=o>::</span><span class=n>unique_lock</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>mutex</span><span class=o>&gt;</span> <span class=n>lk</span><span class=p>(</span><span class=n>mut</span><span class=p>);</span>   <span class=c1>//这里使用unique_lock是为了后面方便解锁</span>
        <span class=n>data_cond</span><span class=p>.</span><span class=n>wait</span><span class=p>(</span><span class=n>lk</span><span class=p>,{[]</span><span class=k>return</span> <span class=o>!</span><span class=n>data_queue</span><span class=p>.</span><span class=n>empty</span><span class=p>();});</span>
        <span class=n>data_chunk</span> <span class=n>data</span><span class=o>=</span><span class=n>data_queue</span><span class=p>.</span><span class=n>front</span><span class=p>();</span>
        <span class=n>data_queue</span><span class=p>.</span><span class=n>pop</span><span class=p>();</span>
        <span class=n>lk</span><span class=p>.</span><span class=n>unlock</span><span class=p>();</span>
        <span class=n>process</span><span class=p>(</span><span class=n>data</span><span class=p>);</span>
        <span class=k>if</span><span class=p>(</span><span class=n>is_last_chunk</span><span class=p>(</span><span class=n>data</span><span class=p>))</span>
            <span class=k>break</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div> <p>1）wait()的实现接下来检查条件，并在满足时返回。如果条件不满足，wait()解锁互斥元，并将该线程置于阻塞或等待状态。当来自数据准备线程中对notify_one()的调用通知条件变量时，线程从睡眠状态中苏醒（解除其阻塞），重新获得互斥元上的锁，并再次检查条件，如果条件已经满足，就从wait()返回值，互斥元仍被锁定。如果条件不满足，该线程解锁互斥元，并恢复等待。</p> <p>2）如果等待线程只打算等待一次，那么当条件为true时它就不会再等待这个条件变量了，条件变量未必是同步机制的最佳选择。如果等待的条件是一个特定数据块的可用性时，这尤其正确。在这个场景中，使用期值（future）更合适。使用future等待一次性事件。</p> <h2 id=_2>自旋锁<a class=headerlink href=#_2 title="Permanent link">&para;</a></h2> <p>前面的两种锁是比较常见的锁，也比较容易理解。下面通过比较互斥锁和自旋锁原理的不同，这对于真正理解自旋锁有很大帮助。</p> <p>假设我们有一个两个处理器core1和core2计算机，现在在这台计算机上运行的程序中有两个线程：T1和T2分别在处理器core1和core2上运行，两个线程之间共享着一个资源。</p> <p>首先我们说明互斥锁的工作原理，互斥锁是是一种sleep-waiting的锁。假设线程T1获取互斥锁并且正在core1上运行时，此时线程T2也想要获取互斥锁（pthread_mutex_lock），但是由于T1正在使用互斥锁使得T2被阻塞。当T2处于阻塞状态时，T2被放入到等待队列中去，处理器core2会去处理其他任务而不必一直等待（忙等）。也就是说处理器不会因为线程阻塞而空闲着，它去处理其他事务去了。</p> <p>而自旋锁就不同了，自旋锁是一种busy-waiting的锁。也就是说，如果T1正在使用自旋锁，而T2也去申请这个自旋锁，此时T2肯定得不到这个自旋锁。与互斥锁相反的是，此时运行T2的处理器core2会一直不断地循环检查锁是否可用（自旋锁请求），直到获取到这个自旋锁为止。</p> <p>从“自旋锁”的名字也可以看出来，如果一个线程想要获取一个被使用的自旋锁，那么它会一致占用CPU请求这个自旋锁使得CPU不能去做其他的事情，直到获取这个锁为止，这就是“自旋”的含义。</p> <p>当发生阻塞时，互斥锁可以让CPU去处理其他的任务；而自旋锁让CPU一直不断循环请求获取这个锁。通过两个含义的对比可以我们知道“自旋锁”是比较耗费CPU的。</p> <div class=highlight><pre><span></span><code><span class=c1>//使用std::atomic_flag的自旋锁互斥实现</span>
<span class=k>class</span> <span class=nc>spinlock_mutex</span>
<span class=p>{</span>
    <span class=n>std</span><span class=o>::</span><span class=n>atomic_flag</span> <span class=n>flag</span><span class=p>;</span>
<span class=k>public</span><span class=o>:</span>
<span class=n>spinlock_mutex</span><span class=p>()</span><span class=o>:</span><span class=n>flag</span><span class=p>(</span><span class=n>ATOMIC_FLAG_INIT</span><span class=p>)</span> <span class=p>{}</span>
<span class=kt>void</span> <span class=n>lock</span><span class=p>()</span>
<span class=p>{</span>
    <span class=k>while</span><span class=p>(</span><span class=n>flag</span><span class=p>.</span><span class=n>test_and_set</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>));</span>
<span class=p>}</span>
<span class=kt>void</span> <span class=n>unlock</span><span class=p>()</span>
<span class=p>{</span>
    <span class=n>flag</span><span class=p>.</span><span class=n>clear</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_release</span><span class=p>);</span>
<span class=p>}</span>
<span class=p>}</span>
</code></pre></div> <h2 id=_3>读写锁<a class=headerlink href=#_3 title="Permanent link">&para;</a></h2> <p>说到读写锁我们可以借助于“读者-写者”问题进行理解。首先我们简单说下“读者-写者”问题。</p> <p>计算机中某些数据被多个进程共享，对数据库的操作有两种：一种是读操作，就是从数据库中读取数据不会修改数据库中内容；另一种就是写操作，写操作会修改数据库中存放的数据。因此可以得到我们允许在数据库上同时执行多个“读”操作，但是某一时刻只能在数据库上有一个“写”操作来更新数据。这就是一个简单的读者-写者模型。</p> <p>头文件：boost/thread/shared_mutex.cpp 类型：boost::shared_lock</p> <p>用法：你可以使用boost::shared_ mutex的实例来实现同步，而不是使用std::mutex的实例。对于更新操作，std::lock_guard&lt; boost::shared _mutex&gt;和 std::unique _lock&lt; boost::shared _mutex&gt;可用于锁定，以取代相应的std::mutex特化。这确保了独占访问，就像std::mutex那样。那些不需要更新数据结构的线程能够转而使用 boost::shared _lock&lt; boost::shared _mutex&gt;来获得共享访问。这与std::unique _lock用起来正是相同的，除了多个线程在同一时间，同一boost::shared _mutex上可能会具有共享锁。唯一的限制是，如果任意一个线程拥有一个共享锁，试图获取独占锁的线程会被阻塞，知道其他线程全都撤回它们的锁。同样的，如果一个线程具有独占锁，其他线程都不能获取共享锁或独占锁，直到第一个线程撤回它的锁。</p> <br> <div class="row wm-article-nav-buttons" role=navigation aria-label=navigation> <div class="wm-article-nav pull-right"> <a href=../../Libevent/ class="btn btn-xs btn-default pull-right"> Next <i class="fa fa-chevron-right" aria-hidden=true></i> </a> <a href=../../Libevent/ class="btn btn-xs btn-link"> 开始 </a> </div> <div class=wm-article-nav> <a href=../%E6%AD%BB%E5%BE%AA%E7%8E%AF%E5%86%85%E7%9A%84sleep%E5%87%BD%E6%95%B0/ class="btn btn-xs btn-default pull-left"> <i class="fa fa-chevron-left" aria-hidden=true></i> Previous</a><a href=../%E6%AD%BB%E5%BE%AA%E7%8E%AF%E5%86%85%E7%9A%84sleep%E5%87%BD%E6%95%B0/ class="btn btn-xs btn-link"> 死循环内的sleep函数 </a> </div> </div> <br> </div> <footer class="container-fluid wm-page-content"><p>Copyright &copy; 2020 - 2020 张磊</p> <p>Documentation built with <a href=http://www.mkdocs.org/ >MkDocs</a> using <a href=https://github.com/gristlabs/mkdocs-windmill>Windmill</a> theme by Grist Labs.</p> </footer> </body> </html>